# 1. 알고리즘 분류 방법
### An algorithm whose worst-case time complexity is bounded above by a polynomial function of its input size n
- 2n, n^3+4n, n*log n (n*log n < n^2이기 때문)은 ploynomnial, 2^n, n^sqrt(n), n!등은 not polynomial

### decidable vs undecidable problems
- decidable problem: It has been proved that the problem has an algorithm that solves it.(=problem solvable on computer) The algorithm my be polynomial or exponential.
- undecidable problem: It has been proved that it is impossible to develop an algorithm regardless of the computing time.(=impossible to solve on computer)

### Tractable vs Intractable problems
- tractable(=easy problem): It has at least one algorithm that solve the problem in time O(n^k)
- Intractable(=hard problem): the problem needs more than polynomial time
- Intractable은 algorithm의 특성이 아니라 알고리즘이 적용되는 문제에 종속적인 특성이다. (어떤 문제가 tractable/intractable이라 말하지 어떤 알고리즘이 tractable/intractable이라 하지 않는다)
- 3 general categories of problems
  - tractable: at least one polynomial time algorithm has been found for problems  
  - intractable: problems that have been proven to. e intractable
  - neither tractable nor intractable. Until current, no polynomial time algorithm has been found and has not been proved that it is impossible to develop a polynomial time algorithm. 미래에 알고리즘을 찾거나 불가능하다는 것이 증명될 것이다.
- types of intractable problems
  1. problem requires a non-polynomial number of outputs.(exponential number of outputs) -> required size of the output is not reasonable and the definition of the problem is unrealistic
    - eg. determining all Hamiltonian circuits problem. 하지만 only one circuit을 output으로 요청하는 문제는 intractable problem이 당연히 아니다.
  2. Some problems are intractable inherently although they require reasonable number of outputs.
    - eg. 0-1 knapsack decision problem. 이 문제는 worst case에서 polynomial time을 만족하는 알고리즘이 없기 때문이다.

### Turing’s halting problem
- example of undecidable/intractable problem (decision problem이지만 undecidable한 문제의 예시이다.)
- Given any computer program P and an input I to it, will the program P halt on that input instance or continue working indefinitely on it?
- A를 halting problem을 푸는 알고리즘이라 하자.
  - Input of program P: input instance I
  - Output of program P: anything
  - Input of algorithm A: P and I
  - Output of algorithm A: true or false
- Can we develop an algorithm A that takes the program P and input instance I as its input and return true if the program halts or returns false if the program continue? -> No (1936년에 컴퓨팅 시간에 상관없이 불가능하다는 것이 증명되었다.)

# 2. Core of theory of NP
- why theory of NP is developed using only decision problems?
  - Because the output of a decision problem is simple yes or no.
  - Optimization problems can be transformed into decision problems.
  - Optimization problems are at least as hard as the associated decision problem.
  - If polynomial-time algorithm for the optimization problem is found, we would have a polynomial time algorithm for the corresponding decision problem.
  - 0-1 knapsack problem에서 최대 이득을 위해 가방 무게 W 이내로 넣어야 될 물품들을 정하는 문제(optimization problem)은 주어진 profit p를 만족하며 가방의 무게를 W 이하가 되게 물건을 담을 수 있냐 없냐 문제(decision problem)으로 바꿀 수 있다.

### Common features of combinatory decision problems
- They have an exponential number of possible options, as a function of input size, from which a solution needs to be selected.
- Although it is difficult to develop a polynomial time algorithm to solve them, the validity of a proposed solution can be verified in polynomial time. -> 이를 이용해 non deterministic algorithm

### Non-deterministic algorithm
-  **Definition 1**: Non-deterministic algorithm is a two stage procedure that takes as its input a particular instance I of a decision problem and does the following operations at each stage.
  - Guessing(non deterministic) stage: an arbitrary string S(guess) is generated by a computer as a candidate solution to a given instance I. -> this stage has **no** unique step-by-step instructions.
  - Verification(deterministic) stage: a deterministic algorithm takes both I and S as its input and do one of below
    - stop by returning yes if the guess S is a solution
    - stop by returning false if S is not solution
    - continue forever
  - example of non deterministic algorithm: Traveling salesperson problem
    - 외판원이 최단경로로 모든 집들을 들른 후 시작위치로 돌아오는 문제
    - computer가 외판원의 방문 장소 순서를 random하게 생성한다. 각 리스트를 따라 외판원이 방문을 할 경우 총 거리가 15 이하가 되는가? (decision problem)
- we say that a non deterministic algorithm solves a decision problem if and only if for every yes instance of the problem it returns yes by taking some execution time.
- If the verification stage of a non deterministic algorithm is a polynomial time algorithm, the algorithm is called **_non deterministic polynomial algorithm_**

# 3. Definition of P and NP classes
- **Definition 2**:Class NP is the set of all decision problems that can be solved by non deterministic polynomial algorithm.
  - non deterministic polynomial algorithm을 사용하기 때문에 NP 문제는 **_Polynomial time verifiability_** 특성을 가진다.
  - Verification stage는 random string(=guess)를 생성하는 시간은 포함하지 않는다.
- **Definition 3**:Class P is the set of all decision problems that can be solved by deterministic polynomial time algorithm
- 즉 verification 단계에서 polynomial time의 시간만 걸리는가로 NP문제냐 NP문제가 아니냐는 구분할 수 있다. NP 문제가 아니라고 해서 P문제인 것은 아니다.(P와 NP가 반대 의미가 아니다.)
- Class P는 Class NP에 속한다. (NP의 부분집합이다.) 그렇다면 NP또한 P의 부분집합인가? 혹은 P=NP인가? 밀레니엄 문제.

# 4. Transformation algorithm and NP-Complete problem
- **Definition 4**:A decision problem D1 is said to be polynomially reducible into another decision problem D2, if there is a function F that transforms specific instances of D1 to specific instance of D2
- definition 4를 통해 만약 problem D2를 다항 시간 내에 풀 수 있다면 D1 또한 다항 시간 내에 풀 수 있음을 알 수 있다.
- **Definition 5**: A decision problem D is said to be NP-complete if
  1. it belongs to set NP
  2. **every** problem in set NP is polynomially reducible to D (known뿐만 아니라 unknown NP문제들도 해당 problem으로 polynomial reducible해야한다.)
- CNF-satisfiability problem은 1971년에 발견된 첫 번째 NP-complete problem이다. -> CNF satisfiability problem이 P라면 전체 NP문제가 CNF problem으로 reduce될 수 있으므로 P=NP가 증명된다.

### CNF-satisfiability problem
- A logical variable has two possible values: true or false
- A literal is a logical variable or negation of logical variable
- A clause is a sequence of literals separated by logical “or(v라고 표기)” operator
- A logical expression in Conjunctive Normal Form(CNF) is a sequence of clauses by logical “and (러시아어 데와 비슷하게 표기, 여기선 A라고 비슷하게 표시하겠음)” operator
  - Instance 1: (x1 v notx2 v notx3) A (notx1 v x2) A (notx1 v notx2 v notx3)
  - instance 2: (x1 v x2) A notx2 A notx2
- CNF satisfiability decision problem: is it possible to assign values true and false to variables of a given logical expression in its CNF form to make the entire expression true?
  - for instance 1, x1=true, x2=true, x3=false라면 전체가 true가 된다.
  - for instance 2, CNF satisfiability is no(전체가 true가 되게 x1, x2에 boolean 값을 배정할 수 없다)
- How to prove CNF satisfiability problem is NP-complete?
  1. first, show that the problem is NP. non deterministic polynomial algorithm을 통해 검증하면 되므로 이 단계는 쉽다.
  2. every problem in NP is reducible to this problem in polynomial time. 이 단계는 어렵다.
    - Since polynomial reduction is transitive, the second step can be done by transforming a known NP-complete problem into this problem in polynomial time.
    - The transitive mapping is better instead of proving the existence of a transformation for all problems in NP.
