# 1. greedy technique
- dynamic programming과 같이 optimization problems를 푼다.
- 과거나 미래의 행동이 현재의 행동에 영향을 주지 않는다고 가정한다.
- 그리디 알고리즘은 현재 시점에서 가장 좋다고 보이는 것을 선택하는 과정을 통해 해를 구한다.
- 구한 해는 국소적으로는 최적해일 수 있지만 전체의 최적해는 아닐 수 있다.
- general guideline for a greedy algorithm
  1. A selection procedure: choose the next item to add to the set. the selection is preformed according to a greedy criterion that satisfies some locally optimal consideration at the time.
  2. A feasibility check: determines if the new set if feasible by checking whether it is possible to complete this set by adding the remaining steps. Can the partially constructed solution can be extended to get the complete solution?
  3. A solution check: determines whether the new set constitutes a solution to the instance

# 2. Minimum spanning tree(MST) 최소 신장 트리
- definitions
  - An undirected graph is called connected if there is a path between every pair of vertices
  - A simple cycle is a path from a vertex to itself with distinct intermediate vertices
  - An acyclic graph is an undirected graph with no simple cycles
  - A rooted tree is an acyclic, connected, undirected graph
  - A spanning tree of a graph G is a tree that contains all the vertices in G
  - 즉 그래프 G의 모든 노드를 포함하며 노드들이 모두 연결되어 있는 경우를 spanning tree라고 부른다. -> 노드는 모두 포함되어 있어야 하지만 간선은 모두 포함되지 않아도 되므로 하나의 그래프에는 여러 신장 트리가 존재한다.

### prim algorithm
- 노드를 중심으로 최소 신장 트리를 만든다.
- 다익스트라 알고리즘과 비슷하지만 다르다. 다익스트라 알고리즘은 해당 노드에서 다른 노드로 가는 최소 경로 찾기, 프림 알고리즘은 최소 신장 트리 만들기. 다익스트라 결과가 프림 결과와 같다는 보장이 없다. 하지만 구현 과정이 매우 비슷하긴 하다.

```swift
import Foundation

class node {
    let num: Int
    var to: [Int] = []
    
    init (num: Int, to: [Int]) {
        self.num = num
        for to in to {
            self.to.append(to)
        }
    }
}

func prim (nodes: [node], costList: [[Int]]) -> [Int] {
    var parent: [Int] = [Int] (repeating: 0, count: nodes.count) // 각 노드의 바로 위 부모 노드를 저장하는 배열
    for i in 0..<parent.count {
        parent[i] = i
    }
    
    let inf: Int = Int.max/2 - 1 // infinite를 표시하기 위한 임의의 큰 수
    let start: Int = 3 // 시작 노드, 여기선 임의로 3번째 노드라고 정했다.
    var cost: [Int] = [Int] (repeating: inf, count: nodes.count) // 각 노드의 cost?를 저장하는 배열
    var check: [Bool] = [Bool] (repeating: false, count: nodes.count) // 노드 방문 정보 저장 배열
    var queue: [node] = [] // 노드 정보를 담을 큐, cost가 가장 작은 노드가 가장 앞으로 오게 정렬할 것이다.
    queue.append(nodes[start])
    cost[start] = 0 // 시작 노드의 cost를 0으로 설정해 준다.
    
    while !queue.isEmpty {
        let node = queue.removeFirst()
        check[node.num] = true
        for to in node.to {
            if !check[to] && cost[to] > costList[node.num][to] {
                cost[to] = costList[node.num][to]
                queue.append(nodes[to])
                parent[to] = node.num
            }
        }
        queue.sort {cost[$0.num] < cost[$1.num]}
    }
    return parent
}

var nodes: [node] = []
nodes.append(node(num: 0, to: [1,3]))
nodes.append(node(num: 1, to: [0,2,3,4]))
nodes.append(node(num: 2, to: [1,4,5]))
nodes.append(node(num: 3, to: [0,1,4,6]))
nodes.append(node(num: 4, to: [1,2,3,5]))
nodes.append(node(num: 5, to: [2,4,6]))
nodes.append(node(num: 6, to: [3,5]))

let inf = Int.max/2 - 1
let costList = [[inf, 10, inf, 5, inf, inf, inf],
                [10, inf, 2, 7, 12, inf, inf],
                [inf, 2, inf, inf, 11, 14, inf],
                [5, 7, inf, inf, 6, inf, 9],
                [inf, 12, 11, 6, inf, 15, inf],
                [inf, inf, 14, inf, 15, inf, 3],
                [inf, inf, inf, 9, inf, 3, inf]]

print(prim(nodes: nodes, costList: costList))
```

- 위와 같이 구현할 경우 O(n^2)으로 매우 오래 걸린다. 우선순위 큐를 이용할 경우 O(n*log n)으로 시간을 줄일 수 있으며 이는 다익스트라 또한 마찬가지다.

### kruskal algorithm
- 간선을 중심으로 최소 신장 트리를 만든다.
```swift
import Foundation

class edge {
    let from: Int
    let to: Int
    let cost: Int
    
    init (from: Int, to: Int, cost: Int) {
        self.from = from
        self.to = to
        self.cost = cost
    }
}

// 부모 노드를 찾는다.
func findParent (arr: [Int], x: Int) -> Int {
    if arr[x] == x {
        return x
    }
    
    return findParent(arr: arr, x: arr[x])
}

// a와 b 노드를 잇는다(같은 부모를 가지게 한다)
func unionParent (arr: inout [Int], a: Int, b: Int) {
    let aa = findParent(arr: arr, x: a)
    let bb = findParent(arr: arr, x: b)
    
    if aa < bb {
        arr[bb] = aa
    } else {
        arr[aa] = bb
    }
}

// 같은 그래프에 속하는지(부모가 같은지) 확인한다
func findParent (arr: [Int], a: Int, b: Int) -> Bool {
    let aa = findParent(arr: arr, x: a)
    let bb = findParent(arr: arr, x: b)
    
    if aa == bb {
        return true
    } else {
        return false
    }
}

func kruskal (edges: [edge]) {
    var edges = edges
    edges.sort { $0.cost < $1.cost} // cost가 낮은 것이 앞으로 오게 정렬
    // 각 노드의 부모 노드 정보를 담고 있는 배열을 만든다
    var parent: [Int] = [Int] (repeating: 0, count: nodes.count)
    for i in 0..<parent.count {
        parent[i] = i
    }
    
    for i in 0..<edges.count {
        let edge: edge = edges[i]
        if !findParent(arr: parent, a: node.from, b: node.to) { // 동일한 부모를 가지고 있는 노드를 연결할 경우 사이클이 생긴다.
            unionParent(arr: &parent, a: node.from, b: node.to) // 부모가 다른 경우 둘을 이어 준다.
        }
    }
}
```

- 노드 수를 n, 간선 수를 m이라 하면 간선들을 최소 거리 기준으로 정렬하는대 O(m*log m), parent 배열 초기화에 O(n), findParent는 최악의 경우 O(m)의 시간복잡도를 가지므로 마지막 for문은 O(m*log m), 간선이 가장 많을 때 m= n(n+1)/2이므로 크루스칼 알고리즘의 사간복잡도는 (n^2 * log n)이다.

# 3. shortest path from single source to many destinations
- floyd warshall 알고리즘은 모든 노드에서 다른 모든 노드로의 최단경로를 구했지만 한 노드에서의 최단경로만 알고 싶은 경우 floyd는 시간이 너무 오래 걸린다.

```swift
import Foundation

// 주어진 cost 배열에서 방문하지 않은(=check가 false인) 가장 작은 값이 있는 index 반환
func findMin (check: [Bool], cost: [Int]) -> Int {
    var min: Int = Int.max
    var index: Int = 0
    
    for i in 0..<cost.count {
        if cost[i] < min && !check[i] {
            index = i
            min = cost[i]
        }
    }
    
    return index
}

func dijk (costList: [[Int]], startNode: Int) -> [Int] {
    var cost: [Int] =  costList[startNode]// 해당 노드에서 다른 노드까지의 거리를 저장할 배열, 반환할 배열이다.
    var check: [Bool] = [Bool] (repeating: false, count: cost.count) // 해당 노드를 방문했는지 기록할 배열
    check[startNode] = true
        
    for _ in 0..<costList.count-1 {
        let current: Int = findMin(check: check, cost: cost)
        check[current] = true // 이전 위치에서 가장 적은 비용으로 이동할 수 있는 곳을 current로 잡는다.
        
        for i in 0..<cost.count {
            if !check[i] && cost[i] > cost[current] + costList[current][i] { // current를 거쳐서 j로 가는 비용이 원래 j로 가는 비용보다 싼 경우
                cost[i] = cost[current] + costList[current][i] // 최솟값을 갱신해 준다
            }
        }
    }

    return cost
}

let inf: Int = Int.max - 10000
var a: [[Int]] = [[0,2,5,1,inf,inf],
                  [2,0,3,2,inf,inf],
                  [5,3,0,3,1,5],
                  [1,2,3,0,1,inf],
                  [inf,inf,1,1,0,2],
                  [inf,inf,5,inf,2,0]]

print(dijk(costList: a, startNode: 0))
```
